// ==================== 模块声明 ====================
// 声明项目的核心模块
mod block;       // 区块结构体和相关功能
mod blockchain;  // 区块链核心逻辑
mod utils;       // 工具函数和用户交互

// ==================== 依赖库导入 ====================
// 导入区块链核心结构体
use blockchain::Blockchain;
// colored: 用于在终端输出彩色文本，提升用户体验
use colored::*;
// std::env: 用于获取命令行参数和环境变量
use std::env;
// std::process: 用于程序退出控制
use std::process;
// 导入所有工具函数，包括用户输入处理和界面显示
use utils::*;

/// # 区块链数据文件路径常量
/// 
/// 定义区块链数据持久化存储的默认文件路径。
/// 使用相对路径，在项目根目录下的data文件夹中存储区块链数据。
/// JSON格式便于人类阅读和调试，同时保持跨平台兼容性。
const BLOCKCHAIN_FILE: &str = "data/blockchain.json";

/// # 程序主入口函数
/// 
/// Rust区块链演示程序的核心控制逻辑。根据命令行参数决定运行模式：
/// - 如果有命令行参数：执行对应的CLI命令后退出
/// - 如果没有参数：启动交互式菜单界面
/// 
/// ## 程序架构
/// 
/// ### CLI模式 (Command Line Interface)
/// 适用于脚本自动化、集成到其他系统或快速操作：
/// - 单次执行：运行指定命令后立即退出
/// - 无用户交互：所有参数通过命令行提供
/// - 适合批处理：可以被shell脚本调用
/// 
/// ### 交互式模式 (Interactive Mode)
/// 适用于学习、演示和详细操作：
/// - 持续运行：提供持久的操作界面
/// - 丰富交互：支持复杂的用户输入和反馈
/// - 用户友好：提供帮助信息和错误提示
/// 
/// ## 初始化流程
/// 1. 解析命令行参数
/// 2. 根据参数决定运行模式
/// 3. 加载或创建区块链实例
/// 4. 执行相应的功能模块
/// 
/// ## 错误处理策略
/// - CLI模式：错误时使用非零退出代码，便于脚本检测
/// - 交互式模式：错误时显示友好提示，继续运行
fn main() {
    // 获取命令行参数向量
    // args[0] 是程序名，args[1..] 是用户提供的参数
    // collect() 将迭代器转换为 Vec<String>
    // env::args() 返回命令行参数的迭代器
    // Vec<String> 是一个字符串向量，存储命令行参数
    // example: ./blockchain mine "Hello, World!" -> args = ["./blockchain", "mine", "Hello, World!"]
    let args: Vec<String> = env::args().collect();
    
    // 检查是否有命令行参数（除了程序名本身）
    if args.len() > 1 {
        // 有参数则进入CLI模式，执行完毕后退出程序
        handle_cli_args(&args);
        return;
    }
    
    // 没有参数则启动交互式模式
    
    // 显示程序启动横幅，展示程序信息和版本
    display_banner();
    
    // 尝试加载现有区块链，如果不存在则创建新的
    // 这确保程序总是有一个可用的区块链实例
    let mut blockchain = load_or_create_blockchain();
    
    // 进入主事件循环，提供持续的用户交互
    loop {
        // 显示主菜单选项
        display_main_menu();
        
        // 获取用户输入并执行对应操作
        // 使用字符串匹配进行命令分发
        match get_user_input().as_str() {
            "1" => mine_new_block(&mut blockchain),           // 挖掘新区块
            "2" => display_blockchain(&blockchain),           // 显示完整区块链
            "3" => validate_blockchain(&blockchain),          // 验证区块链完整性
            "4" => save_blockchain(&blockchain),              // 保存区块链到文件
            "5" => blockchain = load_blockchain(),            // 从文件加载区块链
            "6" => set_difficulty(&mut blockchain),           // 设置挖矿难度
            "7" => display_statistics(&blockchain),           // 显示统计信息
            "8" => batch_mining(&mut blockchain),             // 批量挖矿
            "9" => view_block_details(&blockchain),           // 查看区块详情
            "0" => {
                // 用户选择退出程序
                show_info("感谢使用 Rust 区块链！再见！👋");
                process::exit(0);  // 正常退出，返回状态码0
            }
            _ => show_error("无效选择，请输入 0-9 之间的数字"),
        }
        
        // 操作完成后暂停，让用户查看结果
        // 这改善了用户体验，避免菜单立即刷新
        println!("\n按 Enter 键继续...");
        get_user_input();
    }
}

/// # 命令行参数处理函数
/// 
/// 解析并执行基于命令行的区块链操作。这个函数实现了程序的CLI接口，
/// 支持非交互式的自动化操作，适用于脚本集成和快速任务执行。
/// 
/// ## 支持的命令
/// 
/// ### 挖矿命令 (mine)
/// ```bash
/// ./blockchain mine "我的交易数据"
/// ```
/// - 功能：挖掘包含指定数据的新区块
/// - 参数：可选的区块数据，默认为"命令行挖矿"
/// - 输出：挖矿结果和自动保存状态
/// 
/// ### 验证命令 (validate)
/// ```bash
/// ./blockchain validate
/// ```
/// - 功能：验证整个区块链的完整性
/// - 输出：验证结果，失败时使用非零退出代码
/// - 用途：数据完整性检查、系统健康检测
/// 
/// ### 显示命令 (display)
/// ```bash
/// ./blockchain display
/// ```
/// - 功能：输出完整的区块链信息
/// - 用途：数据查看、系统状态检查
/// 
/// ### 统计命令 (stats)
/// ```bash
/// ./blockchain stats
/// ```
/// - 功能：显示区块链的详细统计信息
/// - 包含：区块数量、总大小、哈希率等指标
/// 
/// ### 帮助命令 (help)
/// ```bash
/// ./blockchain help
/// ./blockchain -h
/// ./blockchain --help
/// ```
/// - 功能：显示所有可用命令和使用方法
/// 
/// ### 版本命令 (version)
/// ```bash
/// ./blockchain version
/// ./blockchain -v
/// ./blockchain --version
/// ```
/// - 功能：显示程序版本信息
/// 
/// ## 错误处理
/// - 未知命令：显示错误信息并返回退出代码1
/// - 操作失败：显示具体错误信息，某些情况下退出程序
/// - 文件访问：自动处理文件不存在的情况
/// 
/// ## 参数
/// * `args` - 命令行参数切片，包含程序名和用户参数
/// 
/// ## 设计考虑
/// - **单一职责**：每个命令只做一件事，便于组合使用
/// - **幂等性**：重复执行相同命令应该产生相同结果
/// - **错误传播**：适当的退出代码便于shell脚本处理
/// - **自动保存**：修改操作后自动保存，避免数据丢失
fn handle_cli_args(args: &[String]) {
    // 使用模式匹配处理第二个参数（索引1，因为索引0是程序名）
    // get(1) 返回 Option<&String>，map() 转换为 Option<&str>
    match args.get(1).map(|s| s.as_str()) {
        Some("mine") => {
            // 挖矿命令：mine [数据]
            // 获取第三个参数作为区块数据，如果没有则使用默认值
            let data = args.get(2).unwrap_or(&"命令行挖矿".to_string()).clone();
            let mut blockchain = load_or_create_blockchain();
            
            println!("🚀 开始命令行挖矿...");
            match blockchain.add_block(data) {
                Ok(_) => {
                    show_success("区块挖矿成功！");
                    // 静默保存，避免在CLI模式下显示额外的用户界面
                    save_blockchain_silent(&blockchain);
                }
                Err(e) => show_error(&format!("挖矿失败: {}", e)),
            }
        }
        Some("validate") => {
            // 验证命令：validate
            let blockchain = load_or_create_blockchain();
            if blockchain.is_chain_valid() {
                show_success("区块链验证通过 ✅");
            } else {
                show_error("区块链验证失败 ❌");
                // 验证失败时使用非零退出代码，便于脚本检测
                process::exit(1);
            }
        }
        Some("display") => {
            // 显示命令：display
            let blockchain = load_or_create_blockchain();
            blockchain.display_chain();
        }
        Some("stats") => {
            // 统计命令：stats
            let blockchain = load_or_create_blockchain();
            display_pretty_stats(&blockchain);
        }
        Some("help") | Some("-h") | Some("--help") => {
            // 帮助命令：支持多种常见的帮助参数格式
            display_help();
        }
        Some("version") | Some("-v") | Some("--version") => {
            // 版本命令：支持多种常见的版本参数格式
            println!("Rust 简单区块链 v1.0.0");
        }
        _ => {
            // 处理未知命令
            show_error("未知命令。使用 'help' 查看可用命令。");
            process::exit(1);  // 非零退出代码表示错误
        }
    }
}

/// # 显示命令行帮助信息
/// 
/// 提供详细的CLI使用说明，包括所有可用命令、参数格式和使用示例。
/// 这是用户了解程序功能的主要途径，设计时注重可读性和实用性。
/// 
/// ## 帮助信息结构
/// 
/// ### 程序标题
/// 使用彩色文本突出显示程序名称和用途
/// 
/// ### 使用语法
/// 展示标准的命令行调用格式
/// 
/// ### 命令列表
/// 列出所有可用命令及其简要说明：
/// - **mine**: 挖掘新区块，可指定区块数据
/// - **validate**: 验证区块链完整性
/// - **display**: 显示完整区块链信息
/// - **stats**: 显示统计信息
/// - **help**: 显示帮助信息
/// - **version**: 显示版本信息
/// 
/// ### 使用示例
/// 提供实际的命令调用示例，帮助用户快速上手
/// 
/// ## 设计原则
/// - **清晰性**：信息组织清晰，易于快速查找
/// - **完整性**：覆盖所有可用功能，不遗漏重要信息
/// - **实用性**：提供可直接复制使用的示例
/// - **一致性**：与实际命令行为保持一致
fn display_help() {
    // 显示彩色标题，提升视觉效果
    println!("{}", "🦀 Rust 简单区块链 - 命令行帮助".bright_cyan());
    println!();
    
    // 显示基本使用语法
    println!("用法:");
    println!("  {} [命令] [参数]", env::args().next().unwrap_or_else(|| "blockchain".to_string()));
    println!();
    
    // 详细列出所有可用命令
    println!("命令:");
    println!("  mine [数据]     挖掘包含指定数据的新区块");
    println!("  validate        验证整个区块链的完整性");
    println!("  display         显示完整的区块链");
    println!("  stats           显示区块链统计信息");
    println!("  help            显示此帮助信息");
    println!("  version         显示版本信息");
    println!();
    
    // 提供实际使用示例
    println!("示例:");
    println!("  {} mine \"我的第一笔交易\"", env::args().next().unwrap_or_else(|| "blockchain".to_string()));
    println!("  {} validate", env::args().next().unwrap_or_else(|| "blockchain".to_string()));
    println!("  {} display", env::args().next().unwrap_or_else(|| "blockchain".to_string()));
}

/// # 加载或创建区块链实例
/// 
/// 智能初始化函数，尝试从持久化文件加载现有区块链，
/// 如果文件不存在或加载失败，则创建全新的区块链。
/// 这是程序启动时的关键步骤，确保总有一个可用的区块链实例。
/// 
/// ## 加载策略
/// 
/// ### 优先加载现有数据
/// 1. 尝试从BLOCKCHAIN_FILE指定的文件读取
/// 2. 验证加载的区块链完整性
/// 3. 成功加载时显示区块数量等信息
/// 
/// ### 备用创建新链
/// 当加载失败时（文件不存在、格式错误、验证失败等）：
/// 1. 显示友好的提示信息
/// 2. 创建包含创世区块的新区块链
/// 3. 不会保存到文件，等待用户操作后再保存
/// 
/// ## 用户体验设计
/// - **透明性**：清楚告知用户当前操作状态
/// - **容错性**：各种错误情况都能优雅处理
/// - **一致性**：无论加载还是创建，都返回可用的区块链
/// 
/// ## 安全考虑
/// - **验证加载的数据**：通过is_chain_valid()确保数据完整性
/// - **错误隔离**：文件系统错误不会导致程序崩溃
/// - **默认安全**：新创建的区块链使用安全的默认配置
/// 
/// ## 返回值
/// 返回一个有效的Blockchain实例，要么从文件加载，要么新创建
fn load_or_create_blockchain() -> Blockchain {
    // 尝试从文件加载区块链
    match Blockchain::load_from_file(BLOCKCHAIN_FILE) {
        Ok(blockchain) => {
            // 加载成功，显示成功信息和基本统计
            show_success(&format!("成功加载区块链 ({} 个区块)", blockchain.chain.len()));
            blockchain
        }
        Err(_) => {
            // 加载失败（文件不存在、格式错误等），创建新区块链
            // 使用show_info而不是show_error，因为这是正常的初次运行情况
            show_info("未找到现有区块链，创建新的区块链");
            Blockchain::new()
        }
    }
}

/// # 挖掘新区块功能
/// 
/// 交互式挖矿功能，引导用户输入区块数据并执行挖矿操作。
/// 这是区块链最核心的功能之一，涉及工作量证明和数据持久化。
/// 
/// ## 操作流程
/// 
/// ### 1. 用户输入
/// - 提示用户输入要存储在区块中的数据
/// - 支持任意长度的UTF-8文本
/// - 数据将被永久记录在区块链中
/// 
/// ### 2. 挖矿准备
/// - 显示挖矿准备动画，提升用户体验
/// - 让用户感受到系统正在进行重要操作
/// 
/// ### 3. 执行挖矿
/// - 调用blockchain.add_block()进行实际挖矿
/// - 挖矿过程包括：
///   * 创建新区块结构
///   * 执行工作量证明计算
///   * 验证区块有效性
///   * 链接到区块链末尾
/// 
/// ### 4. 结果处理
/// - 成功：显示成功信息并自动保存区块链
/// - 失败：显示错误信息，不修改区块链状态
/// 
/// ## 安全特性
/// - **原子性操作**：要么完全成功，要么完全失败，不会产生部分状态
/// - **自动验证**：新区块必须通过所有验证才能添加
/// - **自动保存**：成功挖矿后立即持久化，避免数据丢失
/// 
/// ## 用户体验
/// - **进度反馈**：通过加载动画让用户了解进度
/// - **清晰反馈**：成功和失败都有明确的视觉反馈
/// - **错误处理**：友好的错误信息，不暴露技术细节
/// 
/// ## 参数
/// * `blockchain` - 可变区块链引用，用于添加新区块
fn mine_new_block(blockchain: &mut Blockchain) {
    // 获取用户输入的区块数据
    // 这些数据将被永久存储在区块链中，不可修改
    let data = get_string_input("请输入区块数据: ");
    
    // 显示挖矿准备动画，提升用户体验
    // 1000ms的延迟让用户感受到系统正在进行重要操作
    show_loading("准备挖矿", 1000);
    
    // 执行实际的挖矿操作
    match blockchain.add_block(data) {
        Ok(_) => {
            // 挖矿成功
            show_success("区块挖矿成功！");
            // 静默自动保存，避免额外的用户界面干扰
            save_blockchain_silent(blockchain);
        }
        Err(e) => {
            // 挖矿失败，显示具体错误信息
            show_error(&format!("挖矿失败: {}", e));
        }
    }
}

/// # 显示区块链功能
/// 
/// 展示完整区块链信息的简单包装函数。
/// 直接调用区块链的display_chain方法，提供统一的显示格式。
/// 
/// ## 显示内容
/// - 区块链概览信息（总区块数、难度、奖励等）
/// - 每个区块的详细信息（索引、时间戳、数据、哈希等）
/// - 区块间的链接关系可视化
/// - 整个区块链的验证状态
/// 
/// ## 设计理念
/// - **只读操作**：不修改区块链状态，安全可靠
/// - **完整信息**：显示所有重要信息，便于分析和调试
/// - **格式化输出**：使用彩色和符号提升可读性
/// 
/// ## 参数
/// * `blockchain` - 区块链的不可变引用
fn display_blockchain(blockchain: &Blockchain) {
    blockchain.display_chain();
}

/// # 验证区块链完整性功能
/// 
/// 执行全面的区块链完整性检查，验证数据的一致性和有效性。
/// 这是确保区块链数据可信的重要功能，特别是在数据传输或长期存储后。
/// 
/// ## 验证流程
/// 
/// ### 1. 验证准备
/// - 显示验证进度动画，让用户了解系统正在进行重要检查
/// - 1500ms的延迟体现了验证的重要性和复杂性
/// 
/// ### 2. 执行验证
/// 调用blockchain.is_chain_valid()进行全面检查：
/// - **创世区块验证**：确认区块链起始点的正确性
/// - **哈希完整性**：验证每个区块的哈希值正确性
/// - **工作量证明**：确认每个区块满足当时的难度要求
/// - **链式连接**：验证区块间的previous_hash链接正确
/// - **索引连续性**：确认区块索引连续递增
/// 
/// ### 3. 结果反馈
/// - **验证通过**：显示绿色成功信息，确认数据可信
/// - **验证失败**：显示红色错误信息，警示数据问题
/// 
/// ## 安全意义
/// - **防篡改检测**：任何历史数据的修改都会被发现
/// - **完整性保证**：确认区块链从头到尾都是完整的
/// - **信任建立**：为用户提供数据可信度的明确指标
/// 
/// ## 使用场景
/// - **数据传输后**：验证网络传输没有损坏数据
/// - **长期存储后**：确认存储介质没有损坏数据
/// - **系统维护后**：验证维护操作没有影响数据完整性
/// - **定期检查**：作为系统健康检查的一部分
/// 
/// ## 参数
/// * `blockchain` - 区块链的不可变引用
fn validate_blockchain(blockchain: &Blockchain) {
    // 显示验证进度，让用户了解系统正在进行重要操作
    show_loading("验证区块链完整性", 1500);
    
    // 执行全面的区块链验证
    if blockchain.is_chain_valid() {
        show_success("区块链验证通过！所有区块都是有效的。");
    } else {
        show_error("区块链验证失败！检测到无效区块。");
    }
}

/// # 保存区块链到文件功能
/// 
/// 将当前区块链状态序列化并持久化到JSON文件。
/// 这是数据备份和状态保持的核心功能，确保数据不会因程序关闭而丢失。
/// 
/// ## 保存流程
/// 
/// ### 1. 保存准备
/// - 显示保存进度动画，让用户了解正在进行文件操作
/// - 1000ms延迟给用户明确的操作反馈
/// 
/// ### 2. 执行保存
/// 调用blockchain.save_to_file()执行实际保存：
/// - **序列化**：将区块链结构转换为JSON格式
/// - **文件写入**：将JSON数据写入指定文件
/// - **目录创建**：如需要会自动创建目录结构
/// - **原子操作**：确保文件要么完全写入，要么保持原状
/// 
/// ### 3. 结果反馈
/// - **保存成功**：显示文件路径，确认数据已安全存储
/// - **保存失败**：显示错误信息，可能的原因包括权限不足、磁盘空间不足等
/// 
/// ## 数据格式
/// 保存的JSON文件包含：
/// - 所有区块的完整信息
/// - 区块链配置参数（难度、奖励等）
/// - 待处理交易池内容
/// - 格式化的可读性良好的JSON结构
/// 
/// ## 安全特性
/// - **原子写入**：避免写入过程中断导致的文件损坏
/// - **完整性保证**：保存的数据包含完整的区块链状态
/// - **错误处理**：文件系统错误会被妥善处理和报告
/// 
/// ## 使用场景
/// - **手动备份**：用户主动保存重要状态
/// - **程序退出前**：确保数据不会丢失
/// - **重要操作后**：在关键操作后立即保存
/// 
/// ## 参数
/// * `blockchain` - 区块链的不可变引用
fn save_blockchain(blockchain: &Blockchain) {
    // 显示保存进度，给用户明确的操作反馈
    show_loading("保存区块链到文件", 1000);
    
    // 执行实际的文件保存操作
    match blockchain.save_to_file(BLOCKCHAIN_FILE) {
        Ok(_) => show_success(&format!("区块链已保存到 {}", BLOCKCHAIN_FILE)),
        Err(e) => show_error(&format!("保存失败: {}", e)),
    }
}

/// # 静默保存区块链功能
/// 
/// 在后台静默执行区块链保存操作，不显示加载动画或成功信息。
/// 主要用于自动保存场景，避免打断用户的操作流程。
/// 
/// ## 设计目标
/// 
/// ### 最小干扰
/// - 不显示进度动画
/// - 不显示成功提示
/// - 只在失败时显示警告信息
/// 
/// ### 自动化友好
/// - 适用于操作完成后的自动保存
/// - 不需要用户确认或等待
/// - 保持用户界面的流畅性
/// 
/// ## 错误处理策略
/// - **静默成功**：成功时不打断用户操作
/// - **警告失败**：失败时使用警告级别，不是错误级别
/// - **继续运行**：保存失败不会终止当前操作
/// 
/// ## 使用场景
/// - **挖矿成功后**：自动保存新的区块链状态
/// - **配置修改后**：自动保存参数更改
/// - **批量操作中**：定期保存中间状态
/// 
/// ## 参数
/// * `blockchain` - 区块链的不可变引用
fn save_blockchain_silent(blockchain: &Blockchain) {
    // 尝试保存，只在失败时显示提示
    if let Err(e) = blockchain.save_to_file(BLOCKCHAIN_FILE) {
        // 使用警告级别而不是错误级别，因为这是后台操作
        show_warning(&format!("自动保存失败: {}", e));
    }
}

/// # 从文件加载区块链功能
/// 
/// 从持久化文件中读取并恢复区块链状态。
/// 这是数据恢复和状态切换的重要功能，允许用户在不同的区块链版本间切换。
/// 
/// ## 加载流程
/// 
/// ### 1. 加载准备
/// - 显示加载进度动画，让用户了解正在进行文件读取
/// - 1000ms延迟提供明确的操作反馈
/// 
/// ### 2. 执行加载
/// 调用Blockchain::load_from_file()进行文件读取：
/// - **文件读取**：从指定路径读取JSON文件内容
/// - **反序列化**：将JSON数据转换为区块链结构
/// - **完整性验证**：自动验证加载的区块链是否有效
/// - **类型检查**：确保数据格式符合程序期望
/// 
/// ### 3. 结果处理
/// - **加载成功**：显示成功信息和区块数量统计
/// - **加载失败**：显示错误信息并返回当前区块链状态
/// 
/// ## 安全验证
/// 加载过程包含多重安全检查：
/// - **文件完整性**：检查文件是否损坏或不完整
/// - **数据格式**：验证JSON格式和数据结构的正确性
/// - **区块链有效性**：确保加载的区块链通过完整性验证
/// - **版本兼容性**：确保数据格式与当前程序版本兼容
/// 
/// ## 错误恢复
/// 加载失败时的恢复策略：
/// - **保持当前状态**：不会丢失用户当前的工作
/// - **友好提示**：清楚说明失败原因
/// - **继续运行**：程序不会因为加载失败而崩溃
/// 
/// ## 使用场景
/// - **程序启动**：恢复上次关闭时的状态
/// - **数据切换**：在不同的区块链数据间切换
/// - **备份恢复**：从备份文件恢复数据
/// - **测试验证**：加载特定的测试数据
/// 
/// ## 返回值
/// 返回一个有效的Blockchain实例，要么是加载的数据，要么是当前状态
fn load_blockchain() -> Blockchain {
    // 显示加载进度动画
    show_loading("从文件加载区块链", 1000);
    
    // 尝试从文件加载区块链
    match Blockchain::load_from_file(BLOCKCHAIN_FILE) {
        Ok(blockchain) => {
            // 加载成功，显示统计信息
            show_success(&format!("成功加载区块链 ({} 个区块)", blockchain.chain.len()));
            blockchain
        }
        Err(e) => {
            // 加载失败，显示错误并返回默认区块链
            show_error(&format!("加载失败: {}", e));
            show_info("返回当前区块链");
            // 使用load_or_create_blockchain()作为后备方案
            load_or_create_blockchain()
        }
    }
}

/// # 设置挖矿难度功能
/// 
/// 动态调整区块链网络的挖矿难度参数。
/// 这是区块链网络自我调节的重要机制，允许根据网络状况调整挖矿复杂度。
/// 
/// ## 功能流程
/// 
/// ### 1. 显示当前状态
/// - 展示当前的挖矿难度设置
/// - 让用户了解现有配置，便于做出合理调整
/// 
/// ### 2. 获取用户输入
/// - 提示用户输入新的难度值
/// - 限制输入范围在1-10之间，确保系统稳定性
/// - 使用专门的数字输入函数，提供输入验证
/// 
/// ### 3. 应用新设置
/// - 调用区块链的set_difficulty方法
/// - 内置范围检查和参数验证
/// - 自动保存配置更改
/// 
/// ## 难度影响分析
/// 
/// ### 低难度 (1-3)
/// - **优点**：挖矿速度快，适合测试和演示
/// - **缺点**：安全性相对较低
/// - **适用场景**：开发测试、学习演示
/// 
/// ### 中等难度 (4-6)
/// - **优点**：平衡安全性和效率
/// - **缺点**：需要适中的计算资源
/// - **适用场景**：小规模生产环境
/// 
/// ### 高难度 (7-10)
/// - **优点**：高安全性，强工作量证明
/// - **缺点**：挖矿时间长，资源消耗大
/// - **适用场景**：高安全要求的环境
/// 
/// ## 安全限制
/// - **最小值限制**：确保基本的工作量证明要求
/// - **最大值限制**：防止挖矿时间过长影响可用性
/// - **输入验证**：防止无效或恶意输入
/// - **自动保存**：确保配置更改被持久化
/// 
/// ## 参数
/// * `blockchain` - 可变区块链引用，用于修改难度设置
fn set_difficulty(blockchain: &mut Blockchain) {
    // 显示当前挖矿难度，让用户了解现状
    println!("当前挖矿难度: {}", blockchain.difficulty);
    
    // 获取用户输入的新难度值
    if let Some(new_difficulty) = get_number_input("请输入新的挖矿难度 (1-10): ") {
        // 应用新的难度设置（内部会进行范围检查）
        blockchain.set_difficulty(new_difficulty);
        // 静默保存配置更改
        save_blockchain_silent(blockchain);
    } else {
        // 输入无效，显示错误提示
        show_error("无效输入，请输入1-10之间的数字");
    }
}

/// # 显示统计信息功能
/// 
/// 展示详细的区块链统计报告和性能指标。
/// 这是系统监控和性能分析的重要工具，为用户提供全面的网络状态信息。
/// 
/// ## 统计信息类别
/// 
/// ### 基础统计
/// - **区块总数**：反映区块链的规模和历史长度
/// - **总存储大小**：所有区块占用的存储空间
/// - **交易总数**：记录的交易数量（当前简化版本等于区块数）
/// 
/// ### 网络参数
/// - **当前难度**：影响挖矿时间和网络安全的关键参数
/// - **挖矿奖励**：激励矿工参与网络维护的奖励机制
/// 
/// ### 性能指标
/// - **平均出块时间**：反映网络效率的重要指标
/// - **平均哈希率**：网络总算力的估算值
/// - **总尝试次数**：所有挖矿操作的累计工作量
/// 
/// ## 数据用途
/// 
/// ### 性能监控
/// - 识别网络瓶颈和性能问题
/// - 评估难度调整的效果
/// - 监控系统资源使用情况
/// 
/// ### 决策支持
/// - 为难度调整提供数据依据
/// - 评估网络健康状况
/// - 规划系统容量和资源
/// 
/// ### 用户界面
/// - 为管理界面提供可视化数据
/// - 生成系统报告和分析图表
/// - 支持实时监控和告警
/// 
/// ## 参数
/// * `blockchain` - 区块链的不可变引用
fn display_statistics(blockchain: &Blockchain) {
    // 直接调用工具函数显示格式化的统计信息
    display_pretty_stats(blockchain);
}

/// # 批量挖矿功能
/// 
/// 连续自动挖掘指定数量的区块，主要用于测试、演示和快速数据生成。
/// 这个功能展示了区块链的扩展能力和挖矿性能。
/// 
/// ## 操作流程
/// 
/// ### 1. 参数收集
/// - **区块数量**：用户指定要挖掘的区块数量，限制在1-100之间
/// - **数据前缀**：用户提供区块数据的公共前缀
/// - **输入验证**：确保参数在合理范围内，防止系统过载
/// 
/// ### 2. 批量执行
/// 调用blockchain.batch_mine()执行实际挖矿：
/// - **自动编号**：为每个区块生成唯一的数据标识
/// - **进度显示**：实时显示挖矿进度和统计信息
/// - **错误处理**：任何单个区块失败都会中止整个批量操作
/// 
/// ### 3. 结果处理
/// - **成功完成**：显示成功信息并自动保存整个区块链
/// - **中途失败**：显示错误信息，已挖掘的区块会保留
/// 
/// ## 安全限制
/// 
/// ### 数量限制
/// - **最小值**：至少挖掘1个区块，确保操作有意义
/// - **最大值**：最多挖掘100个区块，防止系统过载和长时间占用
/// 
/// ### 完整性保证
/// - **原子性**：要么全部成功，要么在失败点停止
/// - **一致性**：所有成功挖掘的区块都会正确链接
/// - **持久性**：成功完成后立即保存到文件
/// 
/// ## 性能考虑
/// - **资源使用**：大批量挖矿会消耗大量CPU资源
/// - **时间估算**：根据难度和数量，可能需要较长时间完成
/// - **用户体验**：提供进度反馈，避免用户等待焦虑
/// 
/// ## 使用场景
/// - **测试环境**：快速生成测试数据
/// - **性能测试**：评估系统挖矿性能
/// - **演示展示**：展示区块链的工作原理
/// - **压力测试**：测试系统在高负载下的表现
/// 
/// ## 参数
/// * `blockchain` - 可变区块链引用，用于添加新区块
fn batch_mining(blockchain: &mut Blockchain) {
    // 获取要挖掘的区块数量
    if let Some(count) = get_number_input("请输入要挖掘的区块数量: ") {
        // 验证数量在合理范围内
        if count == 0 || count > 100 {
            show_error("区块数量必须在1-100之间");
            return;
        }
        
        // 获取区块数据的公共前缀
        let data_prefix = get_string_input("请输入区块数据前缀: ");
        
        // 执行批量挖矿操作
        match blockchain.batch_mine(count, &data_prefix) {
            Ok(_) => {
                show_success("批量挖矿完成！");
                // 批量操作成功后立即保存
                save_blockchain_silent(blockchain);
            }
            Err(e) => show_error(&format!("批量挖矿失败: {}", e)),
        }
    } else {
        show_error("无效输入，请输入数字");
    }
}

/// # 查看区块详情功能
/// 
/// 提供交互式的单个区块详细信息查看功能。
/// 用户可以通过区块索引精确查看任意区块的完整信息和验证状态。
/// 
/// ## 功能特点
/// 
/// ### 1. 交互式选择
/// - 显示区块链总长度，帮助用户了解可用范围
/// - 允许用户输入特定的区块索引
/// - 提供友好的输入提示和错误处理
/// 
/// ### 2. 详细信息显示
/// 对选中的区块显示完整信息：
/// - **基础信息**：索引、时间戳、数据内容
/// - **哈希信息**：当前哈希值、前驱哈希值
/// - **挖矿信息**：nonce值、难度设置、工作量证明
/// - **存储信息**：区块大小估算
/// 
/// ### 3. 验证状态检查
/// 实时验证区块的各项完整性：
/// - **哈希验证**：检查区块哈希值是否正确计算
/// - **工作量证明**：验证是否满足当时的难度要求
/// - **链接验证**：检查与前一区块的连接关系
/// 
/// ## 验证项目详解
/// 
/// ### 哈希验证
/// - 重新计算区块的哈希值
/// - 与存储的哈希值进行比较
/// - 检测任何数据篡改尝试
/// 
/// ### 工作量证明验证
/// - 验证哈希值是否以足够数量的0开头
/// - 确认满足当时的难度要求
/// - 验证挖矿过程的合法性
/// 
/// ### 链接验证
/// - 检查当前区块的previous_hash是否等于前一区块的hash
/// - 确保区块链的连续性和完整性
/// - 只对非创世区块执行此检查
/// 
/// ## 错误处理
/// - **无效索引**：友好提示用户索引超出范围
/// - **输入错误**：处理非数字输入的情况
/// - **系统错误**：处理意外的系统错误
/// 
/// ## 使用场景
/// - **数据审计**：详细检查特定区块的内容和状态
/// - **问题调试**：定位和分析区块链中的问题
/// - **学习研究**：深入了解区块结构和验证机制
/// - **取证分析**：为数据取证提供详细的技术信息
/// 
/// ## 参数
/// * `blockchain` - 区块链的不可变引用
fn view_block_details(blockchain: &Blockchain) {
    // 显示区块链总长度，帮助用户选择合适的索引
    println!("区块链总长度: {}", blockchain.chain.len());
    
    // 获取用户要查看的区块索引
    if let Some(index) = get_number_input("请输入要查看的区块索引: ") {
        // 尝试获取指定索引的区块
        match blockchain.get_block(index as u64) {
            Some(block) => {
                // 找到区块，显示详细信息
                
                // 显示区块基本信息（使用区块的Display实现）
                println!("\n{}", "🔍 ===== 区块详情 =====".bright_yellow());
                println!("{}", block);
                
                // 显示额外的验证和技术信息
                println!("\n{}", "📊 ===== 额外信息 =====".bright_blue());
                
                // 哈希验证状态
                println!("哈希验证: {}", 
                    if block.is_valid() { 
                        "✅ 通过" 
                    } else { 
                        "❌ 失败" 
                    }
                );
                
                // 工作量证明验证状态
                println!("工作量证明: {}", 
                    if block.has_valid_proof_of_work() { 
                        "✅ 有效" 
                    } else { 
                        "❌ 无效" 
                    }
                );
                
                // 链接验证状态（仅对非创世区块）
                if index > 0 {
                    if let Some(prev_block) = blockchain.get_block(index as u64 - 1) {
                        println!("链接验证: {}", 
                            if block.previous_hash == prev_block.hash { 
                                "✅ 正确" 
                            } else { 
                                "❌ 错误" 
                            }
                        );
                    }
                }
            }
            None => {
                // 区块不存在，显示友好的错误信息
                show_error(&format!("区块索引 {} 不存在", index));
            }
        }
    } else {
        // 输入无效，显示错误提示
        show_error("无效输入，请输入数字");
    }
}